# sleigh specification file for NEC μPD77210 digital signal processor

define endian=little;
define alignment=4;

# U15807EJ2V0UM00.pdf page 20. Instruction memory is specified as "32-bit width × 16-bit words",
# while X/Y data memory is specified as "16-bit width × 16-bit words". I have to assume that both
# are accessed by a 16-bit pointer, while instructions are 32 bits in size, since that's consistent
# with the other manual. Page 62 says the PC is 16-bit, as well.
define space inst     type=ram_space      size=2 wordsize=4 default;
define space data_x   type=ram_space      size=2 wordsize=2;
define space data_y   type=ram_space      size=2 wordsize=2;
define space register type=register_space size=1 wordsize=2;

# U15807EJ2V0UM00.pdf Page 99, 4.5.5 Addressing mode
# Data pointers, 0-3: X memory space, 4-7: Y memory space
define register offset=0x00 size=2 [ DP0 DP1 DP2 DP3 DP4 DP5 DP6 DP7 ];
# Index registers, corresponding to the above, signed
define register offset=0x10 size=2 [ DN0 DN1 DN2 DN3 DN4 DN5 DN6 DN7 ];
# Modulo registers
define register offset=0x20 size=2 [ DMX DMY ];

# Page 64, 4.4.2 (2) Stack (STK) and stack pointer (SP), only a rough implementation
define register offset=0x30 size=2 [ STK SP ];
# Page 71, 4.4.3 Flow control block
define register offset=0x40 size=2 [ RC LSA LEA LC LSR1 LSR2 LSR3 LSP ];
# Page 83, Status register (SR); page 84, Interrupt enable flag stack register (EIR)
define register offset=0x34 size=2 [ SR EIR ];
# Page 91, 4.4.5 Error status register (ESR)
define register offset=0x38 size=2 [ ESR ];

# Page 111, 4.6.2 General-purpose registers and data formats
define register offset=0x80 size=5 [ R0 ];
define register offset=0x80 size=1 [ R0E ];
define register offset=0x81 size=2 [ R0H ];
define register offset=0x83 size=2 [ R0L ];
define register offset=0x81 size=4 [ R0HL ];
define register offset=0x80 size=3 [ R0EH ];

define register offset=0x90 size=5 [ R1 ];
define register offset=0x90 size=1 [ R1E ];
define register offset=0x91 size=2 [ R1H ];
define register offset=0x93 size=2 [ R1L ];
define register offset=0x91 size=4 [ R1HL ];
define register offset=0x90 size=3 [ R1EH ];

define register offset=0xA0 size=5 [ R2 ];
define register offset=0xA0 size=1 [ R2E ];
define register offset=0xA1 size=2 [ R2H ];
define register offset=0xA3 size=2 [ R2L ];
define register offset=0xA1 size=4 [ R2HL ];
define register offset=0xA0 size=3 [ R2EH ];

define register offset=0xB0 size=5 [ R3 ];
define register offset=0xB0 size=1 [ R3E ];
define register offset=0xB1 size=2 [ R3H ];
define register offset=0xB3 size=2 [ R3L ];
define register offset=0xB1 size=4 [ R3HL ];
define register offset=0xB0 size=3 [ R3EH ];

define register offset=0xC0 size=5 [ R4 ];
define register offset=0xC0 size=1 [ R4E ];
define register offset=0xC1 size=2 [ R4H ];
define register offset=0xC3 size=2 [ R4L ];
define register offset=0xC1 size=4 [ R4HL ];
define register offset=0xC0 size=3 [ R4EH ];

define register offset=0xD0 size=5 [ R5 ];
define register offset=0xD0 size=1 [ R5E ];
define register offset=0xD1 size=2 [ R5H ];
define register offset=0xD3 size=2 [ R5L ];
define register offset=0xD1 size=4 [ R5HL ];
define register offset=0xD0 size=3 [ R5EH ];

define register offset=0xE0 size=5 [ R6 ];
define register offset=0xE0 size=1 [ R6E ];
define register offset=0xE1 size=2 [ R6H ];
define register offset=0xE3 size=2 [ R6L ];
define register offset=0xE1 size=4 [ R6HL ];
define register offset=0xE0 size=3 [ R6EH ];

define register offset=0xF0 size=5 [ R7 ];
define register offset=0xF0 size=1 [ R7E ];
define register offset=0xF1 size=2 [ R7H ];
define register offset=0xF3 size=2 [ R7L ];
define register offset=0xF1 size=4 [ R7HL ];
define register offset=0xF0 size=3 [ R7EH ];

# U13116EJ2V0UM00.pdf, Table A-1. Formats of Instruction Words
# For the sake of simplification trinomial instructions use op0/op1/op2 instead of op1/op2/op3,
# so that op1/op2 is consistent between trinomial and binomial instructions
define token opbyte (32)
	fixed_1 = (31, 31)
	fixed_4 = (28, 31)
	opcode_2 = (26, 27)

	op0 = (28, 30)
	op0l = (28, 30)
	op0h = (28, 30)
	opcode = (24, 27)
	op1 = (21, 23)
	op1l = (21, 23)
	op1h = (21, 23)
	op2 = (18, 20)
	op2_dupe = (18, 20)
	op2l = (18, 20)
	op2h = (18, 20)
	dx = (17, 17)
	dy = (16, 16)

	dpx = (14, 15)
	dnx = (14, 15)
	dmx = (14, 14) # HACK
	modix = (11, 13)
	regx = (8, 10) # aka rx
	regxl = (8, 10)
	regxh = (8, 10) # aka rxh
	regxe = (8, 10)
	regxeh = (8, 10)

	dpy = (6, 7)
	dny = (6, 7)
	dmy = (6, 6) # HACK
	modiy = (3, 5)
	regy = (0, 2) # aka ry
	regyl = (0, 2)
	regyh = (0, 2) # aka ryh
	regye = (0, 2)
	regyeh = (0, 2)

	cond = (3, 6)
	top = (0, 2)
	top_hl = (0, 2)

	imm = (0, 15)

	sufx = (23, 25)
	sufy = (20, 22)

	regl = (23, 25)
	regh = (23, 25)
	rege = (23, 25)
	regeh = (23, 25)
	reg = (23, 25)
	suf = (20, 22)
	xy = (19, 19)
	d = (16, 16)
	direct = (0, 15)

	dp = (17, 19)

	source1 = (23, 25)
	flag_22 = (22, 22)
	dest1 = (17, 21)
	flag_16 = (16, 16)

	dest2 = (23, 25)
	source2 = (17, 21)

	flag_25 = (25, 25)
	relative_addr = (7, 22)

	imm_rep_sign = (15, 15)
	imm_rep = (0, 14)

	rl = (0, 2)
	loop_end = (16, 23)

	fixed_rest = (0, 27)
;

attach variables [ reg   regx   regy   op0  op1  op2  op2_dupe     top ] [ R0   R1   R2   R3   R4   R5   R6   R7   ];
attach variables [ regl  regxl  regyl  op0l op1l op2l source1 dest2 rl ] [ R0L  R1L  R2L  R3L  R4L  R5L  R6L  R7L  ];
attach variables [ regh  regxh  regyh  op0h op1h op2h                  ] [ R0H  R1H  R2H  R3H  R4H  R5H  R6H  R7H  ];
attach variables [ rege  regxe  regye                                  ] [ R0E  R1E  R2E  R3E  R4E  R5E  R6E  R7E  ];
attach variables [ regeh regxeh regyeh                                 ] [ R0EH R1EH R2EH R3EH R4EH R5EH R6EH R7EH ];
attach variables [                                              top_hl ] [ R0HL R1HL R2HL R3HL R4HL R5HL R6HL R7HL ];

# Note: sr the following registers are labeled as unconditional and only appear in A-5.
# A-6 gives an extra bit for dest1, but that would require 32 underscores here, so we ignore that.
# lc is labeled as source2 only, as well.
attach variables [ dest1 source2 ] [
	# Conditional
	DP0 DP1 DP2 DP3 DP4 DP5 DP6 DP7
	DN0 DN1 DN2 DN3 DN4 DN5 DN6 DN7
	DMX DMY
	# Unconditional
	SR EIR STK SP LC LSP LSR1 LSR2 LSR3 ESR _ _ _ _
];

# TODO: Check this because Ghidra might be weird with 32-bit word sizes
BranchAddr: rel is relative_addr [ rel = inst_start + relative_addr; ] { export *[inst]:1 rel; }
LoopEnd: rel is loop_end [ rel = inst_start + loop_end; ] { export *[inst]:1 rel; }

attach variables [ dp ] [ DP0 DP1 DP2 DP3 DP4 DP5 DP6 DP7 ];
attach variables [ dpx ] [ DP0 DP1 DP2 DP3 ];
attach variables [ dnx ] [ DN0 DN1 DN2 DN3 ];
attach variables [ dpy ] [ DP4 DP5 DP6 DP7 ];
attach variables [ dny ] [ DN4 DN5 DN6 DN7 ];
# This is a hack to ensure that DMX/DMY show up in the operands
attach variables [ dmx ] [ DMX DMX ];
attach variables [ dmy ] [ DMY DMY ];

#---------------------------------------------------------------------------------------------------
# Instructions
#
# Note that the manual is very jank with regards to instruction formats; they don't document the
# actual encoding with the instructions, but instead in a vague appendix. It's just a guess that
# opcodes are incremental; no numbers are actually given in the manual.
#
# The comments before each instruction are first the "mnemonic" given in the appendix, and then the
# corresponding "mnemonic" given in the instruction explanation section, and then the instruction
# symbol (what I would call a mnemonic), instruction type/category (the functional classification,
# which does not always match the category classification used for encoding instructions; see ch. 2
# for this distinction), and instruction name given in the instruction explanation section.
# These are provided exactly as given in the manual (copy-pasting from the PDF), so they should
# match with ctrl+f searches.
#---------------------------------------------------------------------------------------------------
# Figure A-1. Three-Operand Instruction Format
# Note that we renumbered op1/op2/op3 to op0/op1/op2 so that op1/op2 are consistent
# with 2-operand instructions.
#---------------------------------------------------------------------------------------------------

# op3 = lt (op1,op2)
# ro" = LT (ro, ro')
# LT (Binomial operation): Less than
form3op:"LT" op2 "=" "LT("^op0, op1^")" is op0 & opcode=0 & op1 & op2 {
	op2 = zext(op0 < op1);
}

# op3 = op1h*op2h
# ro = rh * rh'
# MPY (Binomial operation): Multiply
form3op:"MPY" op2 "=" op0h "*" op1h is op0h & opcode=1 & op1h & op2 unimpl

# op3 = op3 + op1h*op2h
# ro = ro + rh * rh'
# MADD (Trinomial operation): Multiply add
# Note: Ghidra doesn't allow you to use op2 twice in the operands, op2_dupe works around that
form3op:"MADD" op2 "=" op2_dupe "+" op0h "*" op1h is op0h & opcode=2 & op1h & op2 & op2_dupe unimpl

# op3 = op3 – op1h*op2h
# ro = ro – rh * rh'
# MSUB (Trinomial operation): Multiply sub
form3op:"MSUB" op2 "=" op2_dupe "-" op0h "*" op1h is op0h & opcode=3 & op1h & op2 & op2_dupe unimpl

# op3 = op3 + op1h*op2l
# ro = ro + rh * rl
# SUMA (Trinomial operation): Sign unsign multiply add
form3op:"SUMA" op2 "=" op2_dupe "+" op0h "*" op1l is op0h & opcode=4 & op1l & op2 & op2_dupe unimpl

# op3 = op3 + op1l*op2l
# ro = ro + rl * rl'
# UUMA (Trinomial operation): Unsign unsign multiply add
form3op:"UUMA" op2 "=" op2_dupe "+" op0l "*" op1l is op0l & opcode=5 & op1l & op2 & op2_dupe unimpl

# op3 = op3 >> 1 + op1h*op2h
# ro = (ro >> 1) + rh * rh'
# MAS1 (Trinomial operation): 1-bit shift multiply add
form3op:"MAS1" op2 "=" "("^op2_dupe ">> 1)" "+" op0h "*" op1h is op0h & opcode=6 & op1h & op2 & op2_dupe unimpl

# op3 = op3 >> 16 + op1h*op2h
# ro = (ro >> 16) + rh * rh'
# MAS16 (Trinomial operation): 16-bit shift multiply add
form3op:"MAS16" op2 "=" "("^op2_dupe ">> 16)" "+" op0h "*" op1h is op0h & opcode=7 & op1h & op2 & op2_dupe unimpl

# op3 = op1 + op2
# ro'' = ro + ro'
# ADD (Binomial operation): Add
form3op:"ADD" op2 "=" op0 "+" op1 is op0 & opcode=8 & op1 & op2 {
	op2 = op0 + op1;
}

# op3 = op1 – op2
# ro'' = ro – ro'
# SUB (Binomial operation): Sub
form3op:"SUB" op2 "=" op0 "-" op1 is op0 & opcode=9 & op1 & op2 {
	op2 = op0 - op1;
}

# op3 = op1 & op2
# ro" = ro & ro'
# AND (Binomial operation): AND
form3op:"AND" op2 "=" op0 "&" op1 is op0 & opcode=10 & op1 & op2 {
	op2 = op0 & op1;
}

# op3 = op1 | op2
# ro" = ro | ro'
# OR (Binomial operation): OR
form3op:"OR" op2 "=" op0 "|" op1 is op0 & opcode=11 & op1 & op2 {
	op2 = op0 | op1;
}

# op3 = op1 ^ op2
# ro" = ro /\ ro'
# XOR (Binomial operation): Exclusive OR
form3op:"XOR" op2 "=" op0 "^" op1 is op0 & opcode=12 & op1 & op2 {
	op2 = op0 ^ op1;
}

# op3 = op1 sra op2l
# ro' = ro SRA rl
# SRA (Binomial operation): Arithmetic right shift
form3op:"SRA" op2 "=" op0 "SRA" op1l is op0 & opcode=13 & op1l & op2 {
	op2 = op0 s>> (op1l & 0x3f);
}

# op3 = op1 srl op2l
# ro' = ro SRL rl
# SRL (Binomial operation): Logical right shift
form3op:"SRL" op2 "=" op0 "SRL" op1l is op0 & opcode=14 & op1l & op2 {
	op2 = op0 >> (op1l & 0x3f);
}

# op3 = op1 sll op2l
# ro' = ro SLL rl
# SLL (Binomial operation): Logical left shift
form3op:"SLL" op2 "=" op0 "SLL" op1l is op0 & opcode=15 & op1l & op2 {
	op2 = op0 << (op1l & 0x3f);
}

#---------------------------------------------------------------------------------------------------
# Figure A-2. Two-Operand Instruction Format
# op1/op2 match the meanings in the manual now.
# From https://www.eevblog.com/forum/microcontrollers/nec-dsp-upd77016-disassembler-help-anyone!/ it
# seems that values 0, 10, and 11 are skipped (but there are 14 entries, so presumably, that thread
# is treating NOP as skipped even though it's explicitly listed in the table, i.e. only 10 and 11
# really should be skipped).
#---------------------------------------------------------------------------------------------------

# nop
# NOP
# NOP (Control): No operation
# This one is weird, since the documentation warns (page 125) that:
# “NOP” is a direction to the ALU and does not mean that the entire instruction word is “NOP”.
# However, the NOP instruction itself doesn't mention that.
form2op:"NOP" is opcode=0 {}

# clr (op2)
# CLR (ro)
# CLR (Monomial operation): Clear
form2op:"CLR" op2 is opcode=1 & op2 {
	op2 = 0;
}

# op2 = op1 + 1
# ro' = ro + 1
# INC (Monomial operation): Increment
form2op:"INC" op2 "=" op1 "+" "1" is opcode=2 & op1 & op2 {
	op2 = op1 + 1;
}

# op2 = op1 – 1
# ro' = ro – 1
# DEC (Monomial operation): Decrement
form2op:"DEC" op2 "=" op1 "-" "1" is opcode=3 & op1 & op2 {
	op2 = op1 - 1;
}

# op2 = abs (op1)
# ro' = ABS (ro)
# ABS (Monomial operation): Absolute value
form2op:"ABS" op2 "=" "ABS("^op1^")" is opcode=4 & op1 & op2 {
	op2 = abs(op1);
}

# op2 = ~op1
# ro' = ~ ro
# NOT (Monomial operation): One’s complement
form2op:"NOT" op2 "=" "~"^op1 is opcode=5 & op1 & op2 {
	op2 = ~op1;
}

# op2 = –op1
# ro' = –ro
# NEG (Monomial operation): Two’s complement
form2op:"NEG" op2 "=" "-"^op1 is opcode=6 & op1 & op2 {
	op2 = -op1;
}

# op2 = clip (op1)
# ro' = CLIP (ro)
# CLIP (Monomial operation): Clip
form2op:"CLIP" op2 "=" "CLIP("^op1^")" is opcode=7 & op1 & op2 unimpl

# op2 = round (op1)
# ro' = ROUND (ro)
# RND (Monomial operation): Round
form2op:"RND" op2 "=" "ROUND("^op1^")" is opcode=8 & op1 & op2 unimpl

# op2 = exp (op1)
# ro' = EXP (ro)
# EXP (Monomial operation): Exponent
form2op:"EXP" op2 "=" "EXP("^op1^")" is opcode=9 & op1 & op2 unimpl

# opcode=10 and opcode=11 assumed to be skipped

# op2 = op1
# ro' = ro
# PUT (Monomial operation): Put
form2op:"PUT" op2 "=" op1 is opcode=12 & op1 & op2 {
	op2 = op1;
}

# op2 / = op1
# ro' / = ro
# DIV (Monomial operation): Divide (1 bit)
form2op:"DIV" op2 "/ =" op1 is opcode=13 & op1 & op2 unimpl

# op2 + = op1
# ro' + = ro
# ACA (Monomial operation): Accumulate add
form2op:"ACA" op2 "+ =" op1 is opcode=14 & op1 & op2 {
	op2 = op2 + op1;
}

# op2 – = op1
# ro' – = ro
# ACS (Monomial operation): Accumulate subtract
form2op:"ACS" op2 "- =" op1 is opcode=15 & op1 & op2 {
	op2 = op2 - op1;
}

#---------------------------------------------------------------------------------------------------
# Figure A-3. Immediate Value Operation Instruction Format
# Opcode has been changed to start at 8 instead of 0, as that results in it matching A-1.
# Presumably there are no immediate multiply instructions.
# See https://www.eevblog.com/forum/microcontrollers/nec-dsp-upd77016-disassembler-help-anyone!/
#---------------------------------------------------------------------------------------------------

# op2 = op1 + imm
# ro' = ro + imm
# IADD (Binomial operation): Immediate add
immop:"IADD" op2 "=" op1 "+" imm is opcode=8 & op1 & op2 & imm {
	op2 = op1 + imm;
}

# op3 = op1 – imm
# ro' = ro – imm
# ISUB (Binomial operation): Immediate sub
# (op3 is a typo in the original manual)
immop:"ISUB" op2 "=" op1 "-" imm is opcode=9 & op1 & op2 & imm {
	op2 = op1 - imm;
}

# op2 = op1 & imm
# ro' = ro & imm
# IAND (Binomial operation): Immediate AND
immop:"IAND" op2 "=" op1 "&" imm is opcode=10 & op1 & op2 & imm {
	op2 = op1 & imm;
}

# op2 = op1 | imm
# ro' = ro | imm
# IOR (Binomial operation): Immediate OR
immop:"IOR" op2 "=" op1 "|" imm is opcode=11 & op1 & op2 & imm {
	op2 = op1 | imm;
}

# op2 = op1 ^ imm
# ro' = ro /\ imm
# IXOR (Binomial operation): Immediate exclusive OR
immop:"IXOR" op2 "=" op1 "^" imm is opcode=12 & op1 & op2 & imm {
	op2 = op1 ^ imm;
}

# op2 = op1 sra imm
# ro' = ro SRA imm
# ISRA (Binomial operation): Immediate arithmetic right shift
immop:"ISRA" op2 "=" op1 "SRA" imm is opcode=13 & op1 & op2 & imm {
	op2 = op1 s>> imm;
}

# op2 = op1 srl imm
# ro' = ro SRL imm
# ISRL (Binomial operation): Immediate logical right shift
immop:"ISRL" op2 "=" op1 "SRL" imm is opcode=14 & op1 & op2 & imm {
	op2 = op1 >> imm;
}

# op2 = op1 sll imm
# ro' = ro SLL imm
# ISLL (Binomial operation): Immediate logical left shift
immop:"ISLL" op2 "=" op1 "SLL" imm is opcode=15 & op1 & op2 & imm {
	op2 = op1 << imm;
}

#---------------------------------------------------------------------------------------------------
# Figure A-4. Load/Store Instruction Format
#
# From https://www.eevblog.com/forum/microcontrollers/nec-dsp-upd77016-disassembler-help-anyone!/
# it seems that the bits in suf correspond bits for l/h/e, while d is the direction, so the strange
# "suf + d" table is mostly not helpful.
#
# Note that we can't create a single Suf table, as table exports need to be the same size, and
# we can't have extra logic saying to sign-extend to the upper bits/ignore the upper bits of e/shift
# so that the l bits are zero.
#---------------------------------------------------------------------------------------------------

# These are used for parallel load/store instructions (LSPA), as well as LSSE. LSPA is implemented
# at the end of this file when creating the root instruction table.
Dpx:"*"^dpx is dpx & modix!=6 { export *[data_x]:2 dpx; }
Dpx:"*!"^dpx is dpx & modix=6 { temp:2 = ~dpx; export *[data_x]:2 temp; }

# This table executes the change to dpx, but does not export the old value of dpx.
# It does show Dpx with formatting, though.
Modix:Dpx is Dpx & modix=1 {}
Modix:Dpx^"++" is Dpx & dpx & modix=2 { dpx = dpx + 1; }
Modix:Dpx^"--" is Dpx & dpx & modix=3 { dpx = dpx - 1; }
# Adjusted to show dnx
Modix:Dpx^"##" dnx is Dpx & dpx & dnx & modix=4 { dpx = dpx + dnx; }
# TODO: Handle actual wrapping
Modix:Dpx^"%%" dnx, dmx is Dpx & dpx & dnx & dmx { dpx = dpx + dnx; }
# Assume that the bit reverse only applies to the value of dpx, not this calculation
Modix:Dpx^"##" dnx is Dpx & dpx & dnx & modix=6 { dpx = dpx + dnx; }

ParallelXAct:"NOPX" is modix=0 {}
ParallelXAct:Modix "=" regxh is dx=0 & Modix & regxh & Dpx { Dpx = regxh; build Modix; }
ParallelXAct:regx "=" Modix is dx=1 & Modix & regx & Dpx { regx = sext(Dpx) << 16; build Modix; }

# The same thing also applies to Y.
Dpy:"*"^dpy is dpy & modiy!=6 { export *[data_y]:2 dpy; }
Dpy:"*!"^dpy is dpy & modiy=6 { temp:2 = ~dpy; export *[data_y]:2 temp; }

Modiy:Dpy is Dpy & modiy=1 {}
Modiy:Dpy^"++" is Dpy & dpy & modiy=2 { dpy = dpy + 1; }
Modiy:Dpy^"--" is Dpy & dpy & modiy=3 { dpy = dpy - 1; }
# Adjusted to show dny
Modiy:Dpy^"##" dny is Dpy & dpy & dny & modiy=4 { dpy = dpy + dny; }
# TODO: Handle actual wrapping
Modiy:Dpy^"%%" dny, dmy is Dpy & dpy & dny & dmy { dpy = dpy + dny; }
# Assume that the bit reverse only applies to the value of dpy, not this calculation
Modiy:Dpy^"##" dny is Dpy & dpy & dny & modiy=6 { dpy = dpy + dny; }

ParallelYAct:"NOPX" is modiy=0 {}
ParallelYAct:Modiy "=" regyh is dy=0 & Modiy & regyh & Dpy { Dpy = regyh; build Modiy; }
ParallelYAct:regy "=" Modiy is dy=1 & Modiy & regy & Dpy { regy = sext(Dpy) << 16; build Modiy; }

# Partial load/store
# LSSE (Load/Store): Section load/store

PartialXAct:"NOPX" is modix=0 {}
with : sufx=0b001 {
PartialXAct:Modix "=" regxl is regxl & dx=0 & Modix & Dpx { Dpx = regxl; build Modix; }
PartialXAct:regxl "=" Modix is regxl & dx=1 & Modix & Dpx { regxl = Dpx; build Modix; }
}
with : sufx=0b010 {
PartialXAct:Modix "=" regxh is regxh & dx=0 & Modix & Dpx { Dpx = regxh; build Modix; }
PartialXAct:regxh "=" Modix is regxh & dx=1 & Modix & Dpx { regxh = Dpx; build Modix; }
}
with : sufx=0b100 {
PartialXAct:Modix "=" regxe is regxe & dx=0 & Modix & Dpx { Dpx = zext(regxe); build Modix; }
PartialXAct:regxe "=" Modix is regxe & dx=1 & Modix & Dpx { regxe = Dpx:1; build Modix; }
}
PartialXAct:regxeh "=" Modix is sufx=0b110 & regxeh & dx=1 & Modix & Dpx { regxeh = sext(Dpx); build Modix; }
PartialXAct:regx "=" Modix is sufx=0b111 & regx & dx=1 & Modix & Dpx { regx = sext(Dpx) << 16; build Modix; }

PartialYAct:"NOPY" is modiy=0 {}
with : sufy=0b001 {
PartialYAct:Modiy "=" regyl is regyl & dy=0 & Modiy & Dpy { Dpy = regyl; build Modiy; }
PartialYAct:regyl "=" Modiy is regyl & dy=1 & Modiy & Dpy { regyl = Dpy; build Modiy; }
}
with : sufy=0b010 {
PartialYAct:Modiy "=" regyh is regyh & dy=0 & Modiy & Dpy { Dpy = regyh; build Modiy; }
PartialYAct:regyh "=" Modiy is regyh & dy=1 & Modiy & Dpy { regyh = Dpy; build Modiy; }
}
with : sufy=0b100 {
PartialYAct:Modiy "=" regye is regye & dy=0 & Modiy & Dpy { Dpy = zext(regye); build Modiy; }
PartialYAct:regye "=" Modiy is regye & dy=1 & Modiy & Dpy { regye = Dpy:1; build Modiy; }
}
PartialYAct:regyeh "=" Modiy is sufy=0b110 & regyeh & dy=1 & Modiy & Dpy { regyeh = sext(Dpy); build Modiy; }
PartialYAct:regy "=" Modiy is sufy=0b111 & regy & dy=1 & Modiy & Dpy { regy = sext(Dpy) << 16; build Modiy; }

loadstore:"LSSE" PartialXAct^";" PartialYAct is opcode_2=3 & PartialXAct & PartialYAct { build PartialXAct; build PartialYAct; }

# Direct addressing load/store
# dest = *addr OR *addr = source
# LSDA (Load/Store): Direct addressing load/store
Direct: "*"^direct is xy=0 & direct { export *[data_x]:2 direct; }
Direct: "*"^direct is xy=1 & direct { export *[data_y]:2 direct; }

with : opcode_2=2 {
with : suf=0b001 {
loadstore:"LSDA" Direct "=" regl is regl & d=0 & Direct { Direct = regl; }
loadstore:"LSDA" regl "=" Direct is regl & d=1 & Direct { regl = Direct; }
}
with : suf=0b010 {
loadstore:"LSDA" Direct "=" regh is regh & d=0 & Direct { Direct = regh; }
loadstore:"LSDA" regh "=" Direct is regh & d=1 & Direct { regh = Direct; }
}
with : suf=0b100 {
loadstore:"LSDA" Direct "=" rege is rege & d=0 & Direct { Direct = zext(rege); }
loadstore:"LSDA" rege "=" Direct is rege & d=1 & Direct { rege = Direct:1; }
}
# These are only valid for loads
loadstore:"LSDA" regeh "=" Direct is suf=0b110 & regeh & d=1 & Direct { regeh = sext(Direct); }
loadstore:"LSDA" reg "=" Direct is suf=0b111 & reg & d=1 & Direct { reg = sext(Direct) << 16; }
}

# Immediate value modify load/store
# dest = *dp_imm OR *dp_imm = source
# LSIM (Load/Store): Immediate value index load/store

# The manual doesn't specify whether the X bus or the Y bus is used. I assume that DP0 through DP3
# are for the X bus and DP4 through DP7 are the Y bus, since that seems to be the convention (and
# the corresponding bit is also the xy bit in other contexts).
DP:"*"^dp is dp & xy=0 { export *[data_x]:2 dp; }
DP:"*"^dp is dp & xy=1 { export *[data_y]:2 dp; }

with : opcode_2=1 {
with : suf=0b001 {
loadstore:"LSIM" DP^"##" imm "=" regl is regl & DP & d=0 & imm { DP = regl; }
loadstore:"LSIM" regl "=" DP^"##" imm is regl & DP & d=1 & imm { regl = DP; }
}
with : suf=0b010 {
loadstore:"LSIM" DP^"##" imm "=" regh is regh & DP & d=0 & imm { DP = regh; }
loadstore:"LSIM" regh "=" DP^"##" imm is regh & DP & d=1 & imm { regh = DP; }
}
with : suf=0b100 {
loadstore:"LSIM" DP^"##" imm "=" rege is rege & DP & d=0 & imm { DP = zext(rege); }
loadstore:"LSIM" rege "=" DP^"##" imm is rege & DP & d=1 & imm { rege = DP:1; }
}
# These are only valid for loads
loadstore:"LSIM" regeh "=" DP^"##" imm is suf=0b110 & regeh & DP & d=1 & imm { regeh = sext(DP); }
loadstore:"LSIM" reg "=" DP^"##" imm is suf=0b111 & reg & DP & d=1 & imm { reg = sext(DP); }
}

#---------------------------------------------------------------------------------------------------
# Figure A-5. Inter-Register Transfer Instruction Format
# The only instruction here is MOV. Note that a general-purpose register is always on one side,
# while a main bus register is on the other.
#---------------------------------------------------------------------------------------------------

# dest = rl OR rl = source
# MOV (Inter-register transfer): Inter-register transfer
inter:"MOV" dest1 "=" source1 is source1 & dest1 & flag_16=0 {
	dest1 = source1;
}
inter:"MOV" dest2 "=" source2 is source2 & dest2 & flag_16=1 {
	dest2 = source2;
}

#---------------------------------------------------------------------------------------------------
# Figure A-6. Immediate Value Set Instruction Format
# The only instruction is LDI.
#---------------------------------------------------------------------------------------------------

# dest = imm
# LDI (Immediate value set): Immediate value set
immset:"LDI" dest1 "=" imm is dest1 & imm & flag_16=0 {
	dest1 = imm;
}
immset:"LDI" dest2 "=" imm is dest2 & imm & flag_16=1 {
	dest2 = imm;
}

#---------------------------------------------------------------------------------------------------
# Figure A-7. Branch Instruction Format
#---------------------------------------------------------------------------------------------------

# br
# JMP imm
# JMP (Branch): Jump
branch:"JMP" BranchAddr is opcode_2=3 & flag_25=0 & BranchAddr { goto BranchAddr; }

# call
# CALL imm
# CALL (Branch): Subroutine call
branch:"CALL" BranchAddr is opcode_2=3 & flag_25=1 & BranchAddr { STK = inst_next; call BranchAddr; }

# jp
# JMP dp
# JREG (Branch): Register indirect jump
branch:"JREG" dp is opcode_2=2 & flag_25=0 & dp { goto [dp]; }

# callr
# CALL dp
# CREG (Branch): Register indirect subroutine call
branch:"CREG" dp is opcode_2=2 & flag_25=1 & dp { call [dp]; }

# ret
# RET
# RET (Branch): Return
branch:"RET" is opcode_2=1 & flag_25=0 { return [STK]; }

# reti
# RETI
# RETI (Branch): Interrupt return
branch:"RETI" is opcode_2=1 & flag_25=1 { return [STK]; }

#---------------------------------------------------------------------------------------------------
# Figure A-8. Hardware Loop Instruction Format
#---------------------------------------------------------------------------------------------------

# repeat count
# REP count
# REP (Hardware loop): Repeat
loop:"REP" imm_rep is opcode_2=3 & imm_rep_sign=0 & imm_rep unimpl

# repeat rl
# REP count
# REP (Hardware loop): Repeat
# Note: This isn't clearly distinguished, but it DOES exist, see e.g. page 17
loop:"REP" rl is opcode_2=2 & rl unimpl

# loop imm { }
# LOOP count { 2 to 255 instruction words };
# LOOP (Hardware loop): Loop
loop:"LOOP" imm_rep, LoopEnd is opcode_2=1 & LoopEnd & imm_rep_sign=0 & imm_rep unimpl

# loop rl { }
# LOOP count { 2 to 255 instruction words };
# LOOP (Hardware loop): Loop
loop:"LOOP" rl, LoopEnd is opcode_2=0 & LoopEnd & rl unimpl

#---------------------------------------------------------------------------------------------------
# Figure A-9. CPU Control Instruction Format
#---------------------------------------------------------------------------------------------------

# nop
# NOP
# NOP (Control): No operation
# Note that we already had a NOP in A-2. Maybe this is the true NOP, and the other is for load/store
# without any ALU action?
control:"NOP" is fixed_rest=0 {}

# halt
# HALT
# HALT (Control): Halt
control:"HALT" is fixed_rest=1 {
	goto inst_start; # Infinite loop
}

# lpop
# LPOP
# LPOP (Hardware loop): Loop pop
control:"LPOP" is fixed_rest=2 unimpl

# fint
# FINT
# FINT (Control): Forget interrupt
control:"FINT" is fixed_rest=4 unimpl

# stop
# STOP
# STOP (Control): Stop
# Apparently not supported on μPD77016, but it is supported on the rest of the family.
control:"STOP" is fixed_rest=9 {
	goto inst_start; # Infinite loop
}

#---------------------------------------------------------------------------------------------------
# Figure A-10. Conditional Instruction Format
# These are various forms of the COND instruction ("IF (ro cond)").
# There are only 10 entries listed, but one of them is blank, so presumably these are in order.
# The lowest bit seems to indicate negation, so the blank row is is probably NEVER.
#---------------------------------------------------------------------------------------------------

# ever
# EVER: Unconditional (top description not necessary)
# Not implemented, as we instead skip the condition step
# condition:"" is cond=0 { c:1 = 1; export c; }

# blank row skipped (presumably corresponds to cond=1, which is probably NEVER)

# ==0
# ==0: = 0
condition:"IF("^top^" == 0) " is cond=2 & top { c:1 = (top == 0); export c; }

# !=0
# !=0: ≠ 0
condition:"IF("^top^" != 0) " is cond=3 & top { c:1 = (top != 0); export c; }

# >0
# >0: > 0
condition:"IF("^top^" > 0) " is cond=4 & top { c:1 = (top s> 0); export c; }

# <=0
# <=0: ≤ 0
condition:"IF(" top^" <= 0) " is cond=5 & top { c:1 = (top s<= 0); export c; }

# >=0
# >=0: ≥ 0
condition:"IF("^top^" >= 0) " is cond=6 & top { c:1 = (top s>= 0); export c; }

# <0
# <0: < 0
condition:"IF("^top^" < 0) " is cond=7 & top { c:1 = (top s< 0); export c; }

# ==ex
# ==EX: Extension (bits 39 to 31 are a mixture of 0 and 1)
# TODO: Isn't this definition backwards? The sign bit (31) should match all of the following bits if
# the value is equal to its extension.
condition:"IF("^top^" == EXT("^top_hl^")) " is cond=8 & top & top_hl { c:1 = (top == sext(top_hl)); export c; }

# !=ex
# !=EX: Without extension (bits 39 to 31 are all 0 or all 1)
condition:"IF("^top^" != EXT("^top_hl^")) " is cond=9 & top & top_hl { c:1 = (top != sext(top_hl)); export c; }

#---------------------------------------------------------------------------------------------------
# Merge the above together to form the root instruction table.
#---------------------------------------------------------------------------------------------------

:^form3op is fixed_1=1 & form3op & modix=0 & modiy=0 { build form3op; }
:"LSPA+"^form3op ";" ParallelXAct ";" ParallelYAct is fixed_1=1 & form3op & ParallelXAct & ParallelYAct { build form3op; build ParallelXAct; build ParallelYAct; }
:^form2op is fixed_4=7 & form2op & modix=0 & modiy=0 { build form2op; }
:"LSPA+"^form2op ";" ParallelXAct ";" ParallelYAct is fixed_4=7 & form2op & ParallelXAct & ParallelYAct { build form2op; build ParallelXAct; build ParallelYAct; }
:^form2op is fixed_4=6 & form2op & cond=0 { build form2op; }
:^condition form2op is fixed_4=6 & form2op & condition { if (!condition) goto inst_next; build form2op; }
:^immop is fixed_4=5 & immop { build immop; }
:^loadstore is fixed_4=4 & loadstore { build loadstore; }
:^inter is fixed_4=3 & opcode_2=3 & flag_22=0 & inter { build inter; }
:^inter is fixed_4=3 & opcode_2=3 & flag_22=1 & inter & cond=0 { build inter; }
:^condition inter is fixed_4=3 & opcode_2=3 & flag_22=1 & inter & condition { if (!condition) goto inst_next; build inter; }
:^immset is fixed_4=3 & opcode_2=2 & immset { build immset; }
:^branch is fixed_4=2 & branch & cond=0 { build branch; }
:^condition branch is fixed_4=2 & branch & condition { if (!condition) goto inst_next; build branch; }
:^loop is fixed_4=1 & loop { build loop; }
:^control is fixed_4=0 & control { build control; }
