# sleigh specification file for NEC μPD77210 digital signal processor

define endian=big;
define alignment=2;

# U15807EJ2V0UM00.pdf page 20. Instruction memory is specified as "32-bit width × 16-bit words",
# while X/Y data memory is specified as "16-bit width × 16-bit words". I have to assume that both
# are accessed by a 16-bit pointer, while instructions are 32 bits in size, since that's consistent
# with the other manual. Page 62 says the PC is 16-bit, as well.
define space inst     type=ram_space      size=2 wordsize=4 default;
define space data_x   type=ram_space      size=2 wordsize=2;
define space data_y   type=ram_space      size=2 wordsize=2;
define space register type=register_space size=1 wordsize=2;

# U15807EJ2V0UM00.pdf Page 99, 4.5.5 Addressing mode
# Data pointers, 0-3: X memory space, 4-7: Y memory space
define register offset=0x00 size=2 [ DP0 DP1 DP2 DP3 DP4 DP5 DP6 DP7 ];
# Index registers, corresponding to the above, signed
define register offset=0x10 size=2 [ DN0 DN1 DN2 DN3 DN4 DN5 DN6 DN7 ];
# Modulo registers
define register offset=0x20 size=2 [ DMX DMY ];

# Page 83, Status register (SR); page 84, Interrupt enable flag stack register (EIR)
# SR, EIR
# Page 91, 4.4.5 Error status register (ESR)
# More... earlier on, e.g. Page 61.
# ESR

# Page 111, 4.6.2 General-purpose registers and data formats
define register offset=0x80 size=5 [ R0 ];
define register offset=0x80 size=1 [ R0E ];
define register offset=0x81 size=2 [ R0H ];
define register offset=0x83 size=2 [ R0L ];
define register offset=0x81 size=4 [ R0HL ];
define register offset=0x80 size=3 [ R0EH ];

define register offset=0x90 size=5 [ R1 ];
define register offset=0x90 size=1 [ R1E ];
define register offset=0x91 size=2 [ R1H ];
define register offset=0x93 size=2 [ R1L ];
define register offset=0x91 size=4 [ R1HL ];
define register offset=0x90 size=3 [ R1EH ];

define register offset=0xA0 size=5 [ R2 ];
define register offset=0xA0 size=1 [ R2E ];
define register offset=0xA1 size=2 [ R2H ];
define register offset=0xA3 size=2 [ R2L ];
define register offset=0xA1 size=4 [ R2HL ];
define register offset=0xA0 size=3 [ R2EH ];

define register offset=0xB0 size=5 [ R3 ];
define register offset=0xB0 size=1 [ R3E ];
define register offset=0xB1 size=2 [ R3H ];
define register offset=0xB3 size=2 [ R3L ];
define register offset=0xB1 size=4 [ R3HL ];
define register offset=0xB0 size=3 [ R3EH ];

define register offset=0xC0 size=5 [ R4 ];
define register offset=0xC0 size=1 [ R4E ];
define register offset=0xC1 size=2 [ R4H ];
define register offset=0xC3 size=2 [ R4L ];
define register offset=0xC1 size=4 [ R4HL ];
define register offset=0xC0 size=3 [ R4EH ];

define register offset=0xD0 size=5 [ R5 ];
define register offset=0xD0 size=1 [ R5E ];
define register offset=0xD1 size=2 [ R5H ];
define register offset=0xD3 size=2 [ R5L ];
define register offset=0xD1 size=4 [ R5HL ];
define register offset=0xD0 size=3 [ R5EH ];

define register offset=0xE0 size=5 [ R6 ];
define register offset=0xE0 size=1 [ R6E ];
define register offset=0xE1 size=2 [ R6H ];
define register offset=0xE3 size=2 [ R6L ];
define register offset=0xE1 size=4 [ R6HL ];
define register offset=0xE0 size=3 [ R6EH ];

define register offset=0xF0 size=5 [ R7 ];
define register offset=0xF0 size=1 [ R7E ];
define register offset=0xF1 size=2 [ R7H ];
define register offset=0xF3 size=2 [ R7L ];
define register offset=0xF1 size=4 [ R7HL ];
define register offset=0xF0 size=3 [ R7EH ];

# U13116EJ2V0UM00.pdf, Table A-1. Formats of Instruction Words
# For the sake of simplification trinomial instructions use op0/op1/op2 instead of op1/op2/op3,
# so that op1/op2 is consistent between trinomial and binomial instructions
define token opbyte (32)
	fixed_1 = (31, 31)
	fixed_4 = (28, 31)
	fixed_6 = (26, 31)

	op0 = (28, 30)
	op0l = (28, 30)
	op0h = (28, 30)
	opcode = (24, 27)
	op1 = (21, 23)
	op1l = (21, 23)
	op1h = (21, 23)
	op2 = (18, 20)
	op2_dupe = (18, 20)
	op2l = (18, 20)
	op2h = (18, 20)
	dx = (17, 17)
	dy = (16, 16)

	dpx = (14, 15)
	modix = (11, 13)
	rx = (8, 10)
	rxh = (8, 10)
	regx = (8, 10) # TODO: Difference between these?

	dpy = (6, 7)
	modiy = (3, 5)
	ry = (0, 2)
	ryh = (0, 2)
	regy = (0, 2) # TODO: Difference between these?

	cond = (3, 6)
	top = (0, 2)

	imm = (0, 15)

	sufx = (23, 25)
	sufy = (20, 22)

	reg = (23, 25)
	suf = (20, 22)
	xy = (19, 19)
	d = (16, 16)
	direct = (0, 15)

	dp = (17, 19)

	source1 = (23, 25)
	flag_22 = (22, 22)
	dest1 = (17, 21)
	flag_16 = (16, 16)

	dest2 = (23, 25)
	source2 = (17, 21)

	dest1w = (17, 22)

	jc = (25, 25)
	relative_addr = (7, 22)

	rt = (25, 25)

	imm_rep_sign = (15, 15)
	imm_rep = (0, 14)

	rl = (0, 2)
	loop_end = (16, 23)

	fixed_rest = (0, 27)
;

attach variables [ op0  op1  op2  op2_dupe ] [ R0  R1  R2  R3  R4  R5  R6  R7  ];
attach variables [ op0l op1l op2l ] [ R0L R1L R2L R3L R4L R5L R6L R7L ];
attach variables [ op0h op1h op2h ] [ R0H R1H R2H R3H R4H R5H R6H R7H ];

#---------------------------------------------------------------------------------------------------
# Instructions
#
# Note that the manual is very jank with regards to instruction formats; they don't document the
# actual encoding with the instructions, but instead in a vague appendix. It's just a guess that
# opcodes are incremental; no numbers are actually given in the manual.
#
# The comments before each instruction are first the "mnemonic" given in the appendix, and then the
# corresponding "mnemonic" given in the instruction explanation section, and then the instruction
# symbol (what I would call a mnemonic), instruction type/category (the functional classification,
# which does not always match the category classification used for encoding instructions; see ch. 2
# for this distinction), and instruction name given in the instruction explanation section.
# These are provided exactly as given in the manual (copy-pasting from the PDF), so they should
# match with ctrl+f searches.
#---------------------------------------------------------------------------------------------------
# Figure A-1. Three-Operand Instruction Format
# Note that we renumbered op1/op2/op3 to op0/op1/op2 so that op1/op2 are consistent
# with 2-operand instructions.
#---------------------------------------------------------------------------------------------------

# op3 = lt (op1,op2)
# ro" = LT (ro, ro')
# LT (Binomial operation): Less than
form3op:"LT" op2 "=" "LT("^op0, op1^")" is op0 & opcode=0 & op1 & op2 unimpl

# op3 = op1h*op2h
# ro = rh * rh'
# MPY (Binomial operation): Multiply
form3op:"MPY" op2 "=" op0h "*" op1h is op0h & opcode=1 & op1h & op2 unimpl

# op3 = op3 + op1h*op2h
# ro = ro + rh * rh'
# MADD (Trinomial operation): Multiply add
# Note: Ghidra doesn't allow you to use op2 twice in the operands, op2_dupe works around that
form3op:"MADD" op2 "=" op2_dupe "+" op0h "*" op1h is op0h & opcode=2 & op1h & op2 & op2_dupe unimpl

# op3 = op3 – op1h*op2h
# ro = ro – rh * rh'
# MSUB (Trinomial operation): Multiply sub
form3op:"MSUB" op2 "=" op2_dupe "-" op0h "*" op1h is op0h & opcode=3 & op1h & op2 & op2_dupe unimpl

# op3 = op3 + op1h*op2l
# ro = ro + rh * rl
# SUMA (Trinomial operation): Sign unsign multiply add
form3op:"SUMA" op2 "=" op2_dupe "+" op0h "*" op1l is op0h & opcode=4 & op1l & op2 & op2_dupe unimpl

# op3 = op3 + op1l*op2l
# ro = ro + rl * rl'
# UUMA (Trinomial operation): Unsign unsign multiply add
form3op:"UUMA" op2 "=" op2_dupe "+" op0l "*" op1l is op0l & opcode=5 & op1l & op2 & op2_dupe unimpl

# op3 = op3 >> 1 + op1h*op2h
# ro = (ro >> 1) + rh * rh'
# MAS1 (Trinomial operation): 1-bit shift multiply add
form3op:"MAS1" op2 "=" "("^op2_dupe ">> 1)" "+" op0h "*" op1h is op0h & opcode=6 & op1h & op2 & op2_dupe unimpl

# op3 = op3 >> 16 + op1h*op2h
# ro = (ro >> 16) + rh * rh'
# MAS16 (Trinomial operation): 16-bit shift multiply add
form3op:"MAS16" op2 "=" "("^op2_dupe ">> 16)" "+" op0h "*" op1h is op0h & opcode=7 & op1h & op2 & op2_dupe unimpl

# op3 = op1 + op2
# ro'' = ro + ro'
# ADD (Binomial operation): Add
form3op:"ADD" op2 "=" op0 "+" op1 is op0 & opcode=8 & op1 & op2 unimpl

# op3 = op1 – op2
# ro'' = ro – ro'
# SUB (Binomial operation): Sub
form3op:"SUB" op2 "=" op0 "-" op1 is op0 & opcode=9 & op1 & op2 unimpl

# op3 = op1 & op2
# ro" = ro & ro'
# AND (Binomial operation): AND
form3op:"AND" op2 "=" op0 "&" op1 is op0 & opcode=10 & op1 & op2 unimpl

# op3 = op1 | op2
# ro" = ro | ro'
# OR (Binomial operation): OR
form3op:"OR" op2 "=" op0 "|" op1 is op0 & opcode=11 & op1 & op2 unimpl

# op3 = op1 ^ op2
# ro" = ro /\ ro'
# XOR (Binomial operation): Exclusive OR
form3op:"XOR" op2 "=" op0 "/\\" op1 is op0 & opcode=12 & op1 & op2 unimpl

# op3 = op1 sra op2l
# ro' = ro SRA rl
# SRA (Binomial operation): Arithmetic right shift
form3op:"SRA" op2 "=" op0 "SRA" op1l is op0 & opcode=13 & op1l & op2 unimpl

# op3 = op1 srl op2l
# ro' = ro SRL rl
# SRL (Binomial operation): Logical right shift
form3op:"SRL" op2 "=" op0 "SRL" op1l is op0 & opcode=14 & op1l & op2 unimpl

# op3 = op1 sll op2l
# ro' = ro SLL rl
# SLL (Binomial operation): Logical left shift
form3op:"SLL" op2 "=" op0 "SLL" op1l is op0 & opcode=15 & op1l & op2 unimpl

#---------------------------------------------------------------------------------------------------
# Figure A-2. Two-Operand Instruction Format
# op1/op2 match the meanings in the manual now.
#---------------------------------------------------------------------------------------------------

# nop
# NOP
# NOP (Control): No operation
# This one is weird, since the documentation warns (page 125) that:
# “NOP” is a direction to the ALU and does not mean that the entire instruction word is “NOP”.
# However, the NOP instruction itself doesn't mention that.
form2op:"NOP" is opcode=0 unimpl

# clr (op2)
# CLR (ro)
# CLR (Monomial operation): Clear
form2op:"CLR" op2 is opcode=1 & op2 unimpl

# op2 = op1 + 1
# ro' = ro + 1
# INC (Monomial operation): Increment
form2op:"INC" op2 "=" op1 "+" "1" is opcode=2 & op1 & op2 unimpl

# op2 = op1 – 1
# ro' = ro – 1
# DEC (Monomial operation): Decrement
form2op:"DEC" op2 "=" op1 "-" "1" is opcode=3 & op1 & op2 unimpl

# op2 = abs (op1)
# ro' = ABS (ro)
# ABS (Monomial operation): Absolute value
form2op:"ABS" op2 "=" "ABS("^op1^")" is opcode=4 & op1 & op2 unimpl

# op2 = ~op1
# ro' = ~ ro
# NOT (Monomial operation): One’s complement
form2op:"NOT" op2 "=" "~"^op1 is opcode=5 & op1 & op2 unimpl

# op2 = –op1
# ro' = –ro
# NEG (Monomial operation): Two’s complement
form2op:"NEG" op2 "=" "-"^op1 is opcode=6 & op1 & op2 unimpl

# op2 = clip (op1)
# ro' = CLIP (ro)
# CLIP (Monomial operation): Clip
form2op:"CLIP" op2 "=" "CLIP("^op1^")" is opcode=7 & op1 & op2 unimpl

# op2 = round (op1)
# ro' = ROUND (ro)
# RND (Monomial operation): Round
form2op:"RND" op2 "=" "ROUND("^op1^")" is opcode=8 & op1 & op2 unimpl

# op2 = exp (op1)
# ro' = EXP (ro)
# EXP (Monomial operation): Exponent
form2op:"EXP" op2 "=" "EXP("^op1^")" is opcode=9 & op1 & op2 unimpl

# op2 = op1
# ro' = ro
# PUT (Monomial operation): Put
form2op:"PUT" op2 "=" op1 is opcode=10 & op1 & op2 { op2 = op1; }

# op2 / = op1
# ro' / = ro
# DIV (Monomial operation): Divide (1 bit)
form2op:"DIV" op2 "/ =" op1 is opcode=11 & op1 & op2 unimpl

# op2 + = op1
# ro' + = ro
# ACA (Monomial operation): Accumulate add
form2op:"ACA" op2 "+ =" op1 is opcode=12 & op1 & op2 unimpl

# op2 – = op1
# ro' – = ro
# ACS (Monomial operation): Accumulate subtract
form2op:"ACS" op2 "- =" op1 is opcode=13 & op1 & op2 unimpl

:^form3op is fixed_1=1 & form3op { build form3op; }
:^form2op is fixed_4=7 & form2op { build form2op; }
:"IF (COND) "^form2op is fixed_4=6 & form2op { build form2op; } # TODO actually check cond
